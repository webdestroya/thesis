\chapter{Conclusion}
My work with Calico was geared toward solving the three problems found in the previous version of Calico. The first was the instability of Calico. Continual crashes and data loss plagued early versions. To solve this, we redesigned Calico to use a central server that would act as a stable storage system to prevent data loss. The second problem was the lack of support for collaboration. Our decision to move to a client-server architecture provided us with a solution to the problem of collaboration. Now with a centralized server, collaboration could be enabled by allowing multiple clients to connect and ordering concurrent edits to the same elements. The third problem was the lack of extensibility within Calico. Our creation of a well-defined plugin framework allows Calico to now be extended to meet future requirements with minimal change to the core.

\section*{Experiences}
% From these experiences, however, we learned...
% add 2-3 paragraphs about experience

% Not sure what should be in here, we never really ``tested'' the new iteration of calico (and I never studied any results). Should I talk about the use in the classroom, and that it was able to support 30+ students working on it at the same time? (I already talked about that in the previous paragraph)


Calico was used primarily in two environments. The first was within the office of Professor van der Hoek and the software design lab as a full-time whiteboard. The second environment was in a classroom of about thirty students. These two environments allowed Calico to be heavily tested using a typical whiteboard usage pattern. This meant that Calico would be used as often as a whiteboard would have been used if it was installed in the same place.

The first environment to serve as a test installation of Calico was within the office of Professor van der Hoek and within the Software Design and Collaboration Lab. In both locations, we removed the existing whiteboards and replaced them with a Calico setup. Each setup consisted of a dedicated computer running Calico, connected to a Hitachi digital whiteboard. We also mounted short-throw projectors above the digital boards. The short-throw projectors reduced chance that a projector would be touched and the board would need to be recalibrated. For months, Calico was the only permanent drawing tool in both locations. By ``forcing'' members of the lab to utilize Calico as a replacement for the whiteboards, we were able to receive feedback constantly. It also led to many optimizations for both the drawing backend and the Calico user interface.


The classroom environment proved to be far more resource intensive than the office environment. Our first attempt saw a single Calico server instance created for an entire classroom of thirty students to use. During classroom discussions, the students would each be given a tablet computer and were connected to the same Calico instance. During this time, we discovered that Calico was not able to handle thirty users drawing simultaneously, and errors began to appear to users. Users would be randomly dropped by the server causing them to reconnect. This sudden reconnection by many users simultaneously would overwhelm Calico, causing more users to be dropped. Even though Calico encountered problems with stability issues, no data was ever lost. To mitigate these problems, we split the class into groups of five students, and created a server instance for each group. With only five users connected to each server instance, Calico was much more stable and was used for the remainder of the course with very few problems.

During the classroom experiment, we were able to locate a rather serious synchronization bug caused by multiple users. We determined that the Calico server was only able to handle fifteen concurrent users before serious performance problems began to appear. We determined that this was a problem with the way Calico was handling incoming network packets. All packets were being placed on a queue and processed by the \texttt{ProcessQueue} class. This was a bottleneck as clients were forced to wait while the queue was emptied before any response was sent to them. The more clients connected to the server, the longer it took for the queue to empty. To solve this problem, we created a queue for each canvas instead of one for the entire server. This meant that clients were only limited by others on the same drawing space. This limit was necessary to prevent conflicting edits.

Calico's use in the classroom provided us with the most insight into how Calico could be used in a collaborative environment. Student teams utilized Calico on many different occasions, and we were able to see many different diagrams and drawings. Students used Calico to collaborate on various design projects during class time. The most common diagrams we observed were class diagrams and architectural diagrams. Students would sketch very informal diagrams that represented how a design functioned (how components connected with each other, or how data flowed between components). In addition to architecture diagrams we saw students creating lists. Lists could be used to represent tasks that needed to be finished, or to assign tasks to various group members, or to list potential ideas that could be considered. Students also created flow charts to represent the flow of logic through a program. With Calico, these diagrams were easy for students to quickly create and modify. Scraps could be used to represent components, while arrows were used to represent data flow. Students could copy scraps (or groups of scraps) and create multiple diagrams.

The diagrams we observed in the classroom setting were seen again and again in both Professor van der Hoek's office as well as the Calico Lab. Both environments saw a wide variety of diagrams being created. In the Professor van der Hoek's office, we observed that lists were created more than any other type of diagram. Overall, the performance of Calico in both Professor van der Hoek's office and the lab provided very useful data. The deployment also let us test the stability of Calico in a more long-term setting than that of the classroom. Calico was able to run without problems for weeks and even months. Over that time, many different diagrams were created, many different visitors came and used Calico, all without any stability problems. 

% These behaviors much imitated on v.d. Hoek & in the lab. Stable for weeks and months, lots of design, visotrs, etc. Broad variety.
% That is: tell some story about the use in a paragraph or two.

The deployment at the local software development company never saw the usage level that was in the other settings. Due to complications with the projector, the board was constantly out of calibration, and so it was not used nearly as often as any of the other settings. However, we were still able to observe interesting diagrams being created. The boards saw many different diagrams being drawn such as flowcharts, architecture diagrams, database diagrams, and lists. Even though Calico was not used as often in this setting, it still proved to be very stable.

\section*{Future Work}
While the work done to improve Calico was a major stepping stone, there are still many other directions for future work. One direction in particular would be the addition of sessions to Calico. Sessions would allow users to manage multiple server instances from a single administrative interface. This would allow a designer to create a new server that is completely separate from any existing instance (it would not share any canvases). Another feature that would be beneficial would be a subtype of scraps, called Lists. List objects would act just like a normal scrap element with one difference: they would allow content to be ordered within the list. This would allow designers to easily create ordered lists (or unordered) lists that they could easily refer to during development. 
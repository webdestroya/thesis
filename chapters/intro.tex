\chapter{Introduction}
% [Sketching in software design]
% [what limits current systems from doing what we do]
% [with respect to the needs we have, they fall short]
% [how does calico overcome those limitations]

Formal design notations are best used for documenting a system, and do not work well when designing. This is the very reason that many designers turn to a whiteboard in order to sketch their designs. A platform that allows for sketching allows the designer to work without any restrictions at all [ON WHAT?] on designers and the drawings they are able to easily create. Designers are then able to freely manipulate their drawings without the burden of a structured design document. The software is able to aid the designer in creation of their drawing, but does not prevent the flexibility that a traditional whiteboard provides.  

When working at the whiteboard, developers typically draw very informal table-napkin type drawings that are used to quickly build a solution to a given problem. Whiteboards are excellent tools for this, as they provide very little resistance to quick sketching. 

The affinity that designers have for using a whiteboard has been recognized across many different disciplines of design. Sketching plays a very crucial, and very universal role in all applications of design. [this seems so weak?]

Current software design tools offer the user a great amount of power when it comes to tool support. Designers can generate diagrams and other documentation artifacts using these tools. However, these tools do not seem to exist when it comes to sketching. Designers need a tool that is flexible and fluid like a whiteboard, but powerful enough to be useful to designers as a tool.  

Calico is a software-sketching tool used by designers to help them easily draft potential software systems. Calico was designed to be used with a multi-touch whiteboard and projector so that it can replicate the role of a traditional whiteboard. We hoped to build upon the ease-of-use that a whiteboard provides designers, but while at the same time providing options and benefits that a traditional whiteboard system lacks. [I feel like I say this over and over] We hope that Calico can be used to be overcome the limitations of a traditional whiteboard, while not suffering the disadvantages of a structured design tool. While using a whiteboard is very fluid and unrestricted, a whiteboard does not provide any help to a designer – it is identical to pen-and-paper drawings. 

Our research has been about designing Calico, which is very similar to a traditional whiteboard in that it allows the user to sketch freely, but does not suffer from all of the disadvantages that a whiteboard does. One advantage Calico has over a traditional whiteboard is collaboration. Being a distributed, networked design system, Calico can enable designers to collaborate with one another across the globe – something that a traditional whiteboard could never achieve. [what do you think is the best “story” to tell here?]

[RANDOM PARA]To improve the existing version of Calico, we decided to vastly improve the architecture in order to natively support collaboration. We had a few requirements that we wanted to satisfy with the new architecture. The first was the need for the system to be distributed. Originally, we wanted to support two boards that were placed next to each other and just provide a link between those two boards. However, in the end we decided against that and chose to create a system that would allow any number of clients, from various locations to interact on the same space. The second requirement was extensibility. We wanted to easily be able to add plugins and new features to Calico. The previous version proved to be very difficult to add new features, so our goal was to solve that problem, and easily allow new things to be added. The final requirement was reliability. We needed to have a system that was able to stay online, and retain the drawings that we created. Old versions of calico would crash, and then all designs would be lost. By having a centralized server, we hope that the server would be able to outlive client crashes and problems, and could be much more stable because it was not handling any graphical interface. With our new architecture we were able to continually experiment with new features. We could see which features were working well, and which ones were rarely used and could then be removed. The relative ease to adding new features made experimenting with new ideas very easy.
